import numpy as np
import matplotlib.pyplot as plt
from enum import Enum
from random import random, randint

# Channel state can be either IDLE or BUSY
ChannelState = Enum('ChannelState', 'IDLE BUSY')


class Channel:
    """
    A class to represent the channel
    """

    def __init__(self):
        # state of the channel
        self.state = ChannelState.IDLE
        self.time_step = 0

    def start_transmission(self):
        self.state = ChannelState.BUSY
        self.time_step += 1

    def stop_transmission(self):
        self.time_step = 0
        self.state = ChannelState.IDLE


class Node:
    """
    A class which represents a node in a network.
    """
    nodes_cnt = 0

    def __init__(self):
        self.id = Node.nodes_cnt
        Node.nodes_cnt += 1
        # queue count represents the number of frames
        # generated by the current node which has not
        # been transmitted yet.
        self.queue = 0
        # if True, this indicates that this node can
        # transmit a frame in the current time slot.
        self.ready_to_transmit = False

    def generate_frame(self):
        # generate frame is just adding the frame
        # to the queue.
        self.queue += 1

    def transmit_frame(self):
        # transmit frame removes it from the queue and
        # sends it across
        self.queue -= 1

    def can_transmit(self):
        # A node can transmit if it is not waiting or
        # if it has frames in the queue.
        return self.queue > 0


def simulate_csma(n_slots, n_nodes, frame_gen_prob, p, cycles):
    """
    A simultor for the CSMA protocol.

    Parameters:
    -----------
        n_slots: int -> number of slots to simulate
        n_nodes: int -> number of nodes in the network
        frame_gen_prob: float -> the probability of a node generating a frame
        p: float -> the probability of a node transmitting a frame
        cycles: int -> number of cycles to it takes to transmit a frame in the channel

    Returns:
    --------
        success: int -> number of frames successfully sent
    """
    # initialize nodes and channel
    nodes = [Node() for _ in range(n_nodes)]
    channel = Channel()
    success = 0
    for slot in range(n_slots):
        for node in nodes:
            # if node has frames and the channel is idle, it can transmit depending on p
            if node.can_transmit() and channel.state != ChannelState.BUSY and random() <= p:
                node.ready_to_transmit = True
            # A node can generate a frame at the begining of any slot
            if random() <= frame_gen_prob:
                node.generate_frame()
                # if the channel is idle, it can transmit depending on p
                if channel.state != ChannelState.BUSY and random() <= p:
                    node.ready_to_transmit = True

        if channel.state == ChannelState.BUSY:
            # if the frame has reached the destination, change the
            # state of the channel. This indicates the frame was successfully
            # sent.
            if channel.time_step == cycles:
                channel.stop_transmission()
                slot -= 1
                success += 1
            else:
                channel.time_step += 1

            # if channel is busy, all nodes will defer, so we can move-on
            continue

        # nodes that are ready and allowed to transmit
        ready_nodes = [node for node in nodes if node.ready_to_transmit and node.can_transmit()]
        if len(ready_nodes) == 0:
            continue
        elif len(ready_nodes) == 1:
            # if there is only one node transmit it
            for node in nodes:
                if node.can_transmit() and node.ready_to_transmit:
                    node.transmit_frame()
                    channel.start_transmission()
                    node.ready_to_transmit = False
                    break
        else:
            # if there is more than one node, for each node, give
            # a random wait time for each node, after which they
            # will be ready to send frames again.
            for node in ready_nodes:
                node.ready_to_transmit = False
            slot += 3

    return success


if __name__ == '__main__':
    NUMBER_SLOTS = 1000
    NUMBER_NODES = 100
    T_tau_ratio = 3
    lamdas = list(np.random.uniform(low=0, high=1, size=(49,)))
    lamdas.append(1)
    lamdas.sort()
    avgs_half = []
    avgs_one_hundredth = []
    print("Started simulation for p-persistant CSMA")
    print("Running simulation for p=0.5")
    for l in lamdas:
        arr = simulate_csma(NUMBER_SLOTS, NUMBER_NODES, frame_gen_prob=l / NUMBER_NODES, p=0.5, cycles=T_tau_ratio)
        avgs_half.append(arr / NUMBER_SLOTS)
    avgs_half = np.array(avgs_half)
    print("Running simulation for p=0.01")
    for l in lamdas:
        arr = simulate_csma(NUMBER_SLOTS, NUMBER_NODES, frame_gen_prob=l / NUMBER_NODES, p=0.01, cycles=T_tau_ratio)
        avgs_one_hundredth.append(arr / NUMBER_SLOTS)
    avgs_one_hundredth = np.array(avgs_one_hundredth)
    lamdas = np.array(lamdas)
    plt.plot(lamdas, avgs_half, "-r", label="p: 0.5")
    plt.plot(lamdas, avgs_one_hundredth, "-b", label="p: 0.01")
    plt.xlabel("Lambda")
    plt.ylabel("Throughput")
    plt.legend(loc="upper left")
    plt.show()
